//----------------------------------------------------------------------------------------------------------------------------------

#include <stdio.h>      // standard input / output functions
#include <stdlib.h>
#include <string.h>

#include "cJSON.h"

//----------------------------------------------------------------------------------------------------------------------------------

//Data generated by prjtang is json based.

  
//This code is targeted on the AL3-10 device and has fixed parameters for that
  
//The json data starts with a {
//then a strings is expected so look for "
//this is the name field end ends wit again a "
//followed by a : marking the start of the data
//If the next part is a {
//the data is again an array of items
  
//nofbits 2205900   Is the number of database bits per frame times the number of frames, so this matches with the JSON data
//        2198020   The data sheet on the other hand states a lower number of configuration SRAM bits


//In the tile grid the flag signals if this tile has configuration bits connected or if it is just a place holder for block names
//If the flag is -1 the tile has configuration bits and the number of rows and columns give the number of bits used for this tile
//start_frame and start_bit point to the first bit allocated to this tile
//Based on the type of the tile a /bit file is needed. For type pib this is pib.json.
//In this file the actual bits are named based on rows --> y and cols --> x
//cols = 54 means last x = 53. First x = 0

//A bit of a problem is that not all of the type names in tilegrid match one to one with the /bit names
//"miscs_mic_io_l" is one of these

//The tiles with the -1 flag are for the bits, but the problem is matching the bits with there actual names

//For reversing the bitstream back to the tile names it is needed to load it into a frame array first.
//Then map the bits to a tile array based on the info in the tile grid file.

//Best approach for me is to make a manual conversion to a C structure with an x y array setup
//A bit of a snag is that the x y array can have more than one tile types in it


//A better option might be to look from the bit onto the tile information.
//So create a bit based structure that holds information about the bit
//This means looking through the tile grid data for each bit to find its matching tile
//First setup a tile array with bit start and end information.

//So create a list of type names from the tilegrid data and see which don't match with the /bit files


//pib array holds 1458 (27 x 54) items, so for each bit there is an entry
//plb array has 1674 items (31 x 54)
//emb_slice array has 1116 items (2 * 486 = 972???)

//Within these files it is needed to match the x y position to the column row of the configuration bit.
//The question is what the xoff and yoff mean. Also the count and data items.


//For speed sake it is needed to convert the json files to C header files. Is easier then load them and convert to proper C data every time

//----------------------------------------------------------------------------------------------------------------------------------

#define COLUMNS                  35      //x last is 34
#define ROWS                     38      //y last is 37
#define FRAMES                 1075
#define BITS_PER_FRAME         2056
#define DB_BITS_PER_FRAME      2052
#define BRAM_BITS_PER_FRAME    9216
#define GAP                      64

//----------------------------------------------------------------------------------------------------------------------------------

typedef unsigned char  uchar;
typedef unsigned int   uint;
typedef unsigned short uint16;

//----------------------------------------------------------------------------------------------------------------------------------
//A bit dirty but it works for the AL3-10 data

char raw_json_data[2000000];

char c_main_data[3000000];
char c_sub_data[3000000];

char c_db_data[3000000];

char h_db_main_data[3000000];
char h_db_sub_data[3000000];

char *c_db_ptr;

char *h_db_mptr;
char *h_db_sptr;

//----------------------------------------------------------------------------------------------------------------------------------

void convertdottodash(char *string)
{
  while(*string)
  {
    if(*string == '.')
    {
      *string = '_';
    }
    
    string++;
  }
}

//----------------------------------------------------------------------------------------------------------------------------------

void convertbitfile(char *filename, char *Id)
{
  int length;
  char file[255];
  
  char *mptr;
  char *sptr;
  
  int count;
  int datacount;
  int i,j;

  cJSON *json;
  cJSON *item;
  cJSON *name;
  cJSON *data;
  cJSON *field;

  //Set the filename for the input file
  snprintf(file, 255, "/home/peter/Data/Projects/prjtang/database/al3/al3_10/bits/%s.json", filename);
  
  //Open the input file
  FILE *fp = fopen(file, "r");
  
  if(fp)
  {
    //Get the json data for this file
    length = fread(&raw_json_data, 1, sizeof(raw_json_data), fp);

    //Close the file since it is no longer needed
    fclose(fp);
    
    //Parse it for conversion
    json = cJSON_ParseWithLength(raw_json_data, length);

    //Get the number of items in the array
    count = cJSON_GetArraySize(json);
    
    //Only convert the data if there are items to handle
    if(count)
    {
      mptr = c_main_data;
      sptr = c_sub_data;

      //Add the file to the database.c file
      c_db_ptr += sprintf(c_db_ptr, "#include \"%s.h\"\n", filename);
      
      //Add the define for the item count in the database.h file
      h_db_sptr += sprintf(h_db_sptr, "#define %s_COUNT %d\n", filename, count);

      //Declare the array external
      h_db_mptr += sprintf(h_db_mptr, "extern CONFIGBITDATA %s_Data[%d];\n", filename, count);
      
      //Add a data separator
      sptr += sprintf(sptr, "//----------------------------------------------------------------------------------------------------------------------------------\n\n");
      
      //Add the include for the data structures
      sptr += sprintf(sptr, "#include \"configbitdata.h\"\n\n");
      
      //Add a data separator
      sptr += sprintf(sptr, "//----------------------------------------------------------------------------------------------------------------------------------\n\n");
      
      //Start the array
      mptr += sprintf(mptr, "CONFIGBITDATA %s_Data[%d] =\n{\n", filename, count);

      //Process the items
      for(i=0;i<count;i++)
      {
        //Get the current item
        item = cJSON_GetArrayItem(json, i);

        //Start a ne item in the array
        mptr += sprintf(mptr, "  {\n");

        //Copy the name
        name = cJSON_GetObjectItemCaseSensitive(item, "name");
        mptr += sprintf(mptr, "    \"%s\",\n", name->valuestring);

        //Copy the type
        field = cJSON_GetObjectItemCaseSensitive(item, "type");
        mptr += sprintf(mptr, "    \"%s\",\n", field->valuestring);

        //Copy the x coordinate. The json has these two swapped
        field = cJSON_GetObjectItemCaseSensitive(item, "y");
        mptr += sprintf(mptr, "    %d,\n", field->valueint);

        //Copy the y coordinate. The json has these two swapped
        field = cJSON_GetObjectItemCaseSensitive(item, "x");
        mptr += sprintf(mptr, "    %d,\n", field->valueint);

        //Copy the x offset
        field = cJSON_GetObjectItemCaseSensitive(item, "xoff");
        mptr += sprintf(mptr, "    %d,\n", field->valueint);

        //Copy the y offset
        field = cJSON_GetObjectItemCaseSensitive(item, "yoff");
        mptr += sprintf(mptr, "    %d,\n", field->valueint);

        //Copy the map wire arc
        field = cJSON_GetObjectItemCaseSensitive(item, "map_wire_arc");
        mptr += sprintf(mptr, "    %d,\n", field->valueint);

        //Copy the remap
        field = cJSON_GetObjectItemCaseSensitive(item, "remap");
        mptr += sprintf(mptr, "    %d,\n", field->valueint);

        //Copy the pll info
        field = cJSON_GetObjectItemCaseSensitive(item, "pll_info");
        mptr += sprintf(mptr, "    %d,\n", field->valueint);

        //Copy the count
        field = cJSON_GetObjectItemCaseSensitive(item, "cnt");
        mptr += sprintf(mptr, "    %d,\n", field->valueint);

        //Convert dots to underscore in the item name since C variables do not like dots
        convertdottodash(name->valuestring);

        //Get the expr array
        data = cJSON_GetObjectItemCaseSensitive(item, "expr");

        //Get the number of items in the array
        datacount = cJSON_GetArraySize(data);

        //Put the count in the main data
        mptr += sprintf(mptr, "    %d,\n", datacount);

        //Check if there is data
        if(datacount)
        {
          //Hook it to the main data
          mptr += sprintf(mptr, "    %s_%s_EXPR_%d,\n", Id, name->valuestring, i);

          //Make a string array
          sptr += sprintf(sptr, "char *%s_%s_EXPR_%d[%d] = \n{\n", Id, name->valuestring, i, datacount);

          //Print all the strings in this array
          for(j=0;j<datacount;j++)
          {
            //Get the current field and print it
            field = cJSON_GetArrayItem(data, j);
            
            if(strcmp(field->valuestring, "\\") == 0)
            {
              sptr += sprintf(sptr, "  \"\\\\\",\n");
            }
            else
            {
              sptr += sprintf(sptr, "  \"%s\",\n", field->valuestring);
            }
          }

          //Finish the string array
          sptr += sprintf(sptr, "};\n\n");
        }
        else
        {
          //When there are no items set a 0 pointer in the main data
          mptr += sprintf(mptr, "    0,\n");
        }

        //Get the rpn array
        data = cJSON_GetObjectItemCaseSensitive(item, "rpn");

        //Get the number of items in the array
        datacount = cJSON_GetArraySize(data);

        //Put the count in the main data
        mptr += sprintf(mptr, "    %d,\n", datacount);

        //Check if there is data
        if(datacount)
        {
          //Hook it to the main data
          mptr += sprintf(mptr, "    %s_%s_RPN_%d,\n", Id, name->valuestring, i);

          //Make a string array
          sptr += sprintf(sptr, "char *%s_%s_RPN_%d[%d] = \n{\n", Id, name->valuestring, i, datacount);

          //Print all the strings in this array
          for(j=0;j<datacount;j++)
          {
            //Get the current item and print it
            field = cJSON_GetArrayItem(data, j);
            
            if(strcmp(field->valuestring, "\\") == 0)
            {
              sptr += sprintf(sptr, "  \"\\\\\",\n");
            }
            else
            {
              sptr += sprintf(sptr, "  \"%s\",\n", field->valuestring);
            }
          }

          //Finish the string array
          sptr += sprintf(sptr, "};\n\n");
        }
        else
        {
          //When there are no items set a 0 pointer in the main data
          mptr += sprintf(mptr, "    0,\n");
        }

        //Get the data array
        data = cJSON_GetObjectItemCaseSensitive(item, "data");

        //Get the number of items in the array
        datacount = cJSON_GetArraySize(data);

        //Put the count in the main data
        mptr += sprintf(mptr, "    %d,\n", datacount);

        //Check if there is data
        if(datacount)
        {
          //Hook it to the main data
          mptr += sprintf(mptr, "    %s_%s_DATA_%d,\n", Id ,name->valuestring, i);

          //Make a bit data array
          sptr += sprintf(sptr, "BITDATA %s_%s_DATA_%d[%d] = \n{\n", Id, name->valuestring, i, datacount);

          //Print all the strings in this array
          for(j=0;j<datacount;j++)
          {
            //Start the current data set
            sptr += sprintf(sptr, "  {\n");

            //Get the current item and print it
            field = cJSON_GetArrayItem(data, j);
            
            if(strcmp(field->string, "\\") == 0)
            {
              sptr += sprintf(sptr, "  \"\\\\\",\n");
            }
            else
            {
              sptr += sprintf(sptr, "  \"%s\",\n", field->string);
            }
            
            sptr += sprintf(sptr, "    \"%s\",\n", field->valuestring);

            //End the current data set
            sptr += sprintf(sptr, "  },\n");
          }

          //Finish the string array
          sptr += sprintf(sptr, "};\n\n");
        }
        else
        {
          //When there are no items set a 0 pointer in the main data
          mptr += sprintf(mptr, "    0,\n");
        }

        //End the current item in the array
        mptr += sprintf(mptr, "  },\n");
      }

      //End the array
      mptr += sprintf(mptr, "};\n\n");
      
      //Add a data separator
      mptr += sprintf(mptr, "//----------------------------------------------------------------------------------------------------------------------------------\n\n");
      
      //Add a data separator
      sptr += sprintf(sptr, "//----------------------------------------------------------------------------------------------------------------------------------\n\n");
    }

    //Get rid of the json data
    cJSON_Delete(json);
    
    //Set the output file name for the main data
    snprintf(file, 255, "/home/peter/Data/NetbeansProjects/Code_Testing/Anlogic_bitstream_analyzer/database/%s.h", filename);

    //Open the main output file
    fp = fopen(file, "w");

    if(fp)
    {
      fprintf(fp, "%s", c_sub_data);
      fprintf(fp, "%s", c_main_data);

      //Close the main file
      fclose(fp);
    }
  }
}

//----------------------------------------------------------------------------------------------------------------------------------

//                          0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34
int xoffsetmap[COLUMNS] = { 0, 0, 1, 2, 0, 1, 0, 1, 2, 0, 1, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0};

//----------------------------------------------------------------------------------------------------------------------------------

void convertgridfile(char *filename)
{
  int length;
  char file[255];
  
  char *mptr;
  char *sptr;
  
  int count;
  int i,j;
  
  int x,y;
  int xoffset;
  
  cJSON *json;
  cJSON *item;
  cJSON *name;
  cJSON *field;
  cJSON *sites;
  
  int sitecount;
  
  //Set the filename for the input file
  snprintf(file, 255, "/home/peter/Data/Projects/prjtang/database/al3/al3_10/%s.json", filename);
  
  //Open the input file
  FILE *fp = fopen(file, "r");
  
  if(fp)
  {
    //Get the json data
    length = fread(&raw_json_data, 1, sizeof(raw_json_data), fp);

    //Close the file since it is no longer needed
    fclose(fp);
    
    //Parse it for conversion
    json = cJSON_ParseWithLength(raw_json_data, length);

    //Get the number of items in the array
    count = cJSON_GetArraySize(json);

    if(count)
    {
      mptr = c_main_data;
      sptr = c_sub_data;
    
      //Add the file to the database.c file
      c_db_ptr += sprintf(c_db_ptr, "#include \"%s.h\"\n", filename);
      
      //Add the define for the tile count into the database.h file
      h_db_sptr += sprintf(h_db_sptr, "#define TILEGRIDCOUNT %d\n\n", count);

      //Declare the array external
      h_db_mptr += sprintf(h_db_mptr, "extern TILEGRIDDATA TileGridData[%d];\n", count);
      
      //Add a data separator
      sptr += sprintf(sptr, "//----------------------------------------------------------------------------------------------------------------------------------\n\n");
      
      //Add the include for the data structures
      sptr += sprintf(sptr, "#include \"configbitdata.h\"\n\n");
      
      //Add a data separator
      sptr += sprintf(sptr, "//----------------------------------------------------------------------------------------------------------------------------------\n\n");
      
      //Start the array
      mptr += sprintf(mptr, "TILEGRIDDATA TileGridData[%d] =\n{\n", count);

      //Convert all the items in the json array
      for(i=0;i<count;i++)
      {
        item = cJSON_GetArrayItem(json, i);

        field = cJSON_GetObjectItemCaseSensitive(item, "x");
        x = field->valueint;

        field = cJSON_GetObjectItemCaseSensitive(item, "y");
        y = field->valueint;
        
        //For now the xoffset is only set for the top and the bottom row
        if((y == 0) || (y == (ROWS - 1)))
        {
          xoffset = xoffsetmap[x];
        }
        else
        {
          xoffset = 0;
        }
        
        mptr += sprintf(mptr, "  {\n");
        mptr += sprintf(mptr, "    \"%s\",\n", item->string);

        field = cJSON_GetObjectItemCaseSensitive(item, "type");
        mptr += sprintf(mptr, "    \"%s\",\n", field->valuestring);

        //Output the x coordinate
        mptr += sprintf(mptr, "    %d,\n", x);

        //Output the y coordinate
        mptr += sprintf(mptr, "    %d,\n", y);

        //Output the xoffset
        mptr += sprintf(mptr, "    %d,\n", xoffset);
        
        
        field = cJSON_GetObjectItemCaseSensitive(item, "rows");
        mptr += sprintf(mptr, "    %d,\n", field->valueint);

        field = cJSON_GetObjectItemCaseSensitive(item, "cols");
        mptr += sprintf(mptr, "    %d,\n", field->valueint);

        field = cJSON_GetObjectItemCaseSensitive(item, "flag");
        mptr += sprintf(mptr, "    %d,\n", field->valueint);

        field = cJSON_GetObjectItemCaseSensitive(item, "start_frame");
        mptr += sprintf(mptr, "    %d,\n", field->valueint);

        field = cJSON_GetObjectItemCaseSensitive(item, "start_bit");
        mptr += sprintf(mptr, "    %d,\n", field->valueint);

        sites = cJSON_GetObjectItemCaseSensitive(item, "sites");

        sitecount = cJSON_GetArraySize(sites);

        mptr += sprintf(mptr, "    %d,\n", sitecount);

        if(sitecount)
        {
          mptr += sprintf(mptr, "    %s\n", item->string);

          sptr += sprintf(sptr, "TILESITES %s[%d] = \n{\n", item->string, sitecount);

          for(j=0;j<sitecount;j++)
          {
            item = cJSON_GetArrayItem(sites, j);

            sptr += sprintf(sptr, "  {\n");

            field = cJSON_GetObjectItemCaseSensitive(item, "name");
            sptr += sprintf(sptr, "    \"%s\",\n", field->valuestring);

            field = cJSON_GetObjectItemCaseSensitive(item, "type");
            sptr += sprintf(sptr, "    \"%s\",\n", field->valuestring);

            sptr += sprintf(sptr, "  },\n");
          }

          sptr += sprintf(sptr, "};\n\n");
        }
        else
        {
          mptr += sprintf(mptr, "    0\n");
        }

        mptr += sprintf(mptr, "  },\n");
      }

      //End the .h file
      mptr += sprintf(mptr, "};\n");
      
      //Add a data separator
      mptr += sprintf(mptr, "//----------------------------------------------------------------------------------------------------------------------------------\n\n");
      
      //Add a data separator
      sptr += sprintf(sptr, "//----------------------------------------------------------------------------------------------------------------------------------\n\n");
    }

    cJSON_Delete(json);
    
    //Set the output file name for the data
    snprintf(file, 255, "/home/peter/Data/NetbeansProjects/Code_Testing/Anlogic_bitstream_analyzer/database/%s.h", filename);

    //Open the main output file
    fp = fopen(file, "w");

    if(fp)
    {
      fprintf(fp, "%s", c_sub_data);
      fprintf(fp, "%s", c_main_data);

      //Close the main file
      fclose(fp);
    }
  }
}

//----------------------------------------------------------------------------------------------------------------------------------

int main(int argc, char** argv)
{
  FILE *fp;
  
  //Set the pointer for making the database.c file
  c_db_ptr = c_db_data;
  
  //Set the pointers for making the database.h file
  h_db_mptr = h_db_main_data;
  h_db_sptr = h_db_sub_data;
  
  //Start the database.c file
  c_db_ptr += sprintf(c_db_ptr, "//----------------------------------------------------------------------------------------------------------------------------------\n\n");
  
  //Start the database.h file
  //Add a data separator
  h_db_sptr += sprintf(h_db_sptr, "//----------------------------------------------------------------------------------------------------------------------------------\n\n");
  h_db_sptr += sprintf(h_db_sptr, "#ifndef DATABASE_H\n");
  h_db_sptr += sprintf(h_db_sptr, "#define DATABASE_H\n\n");
  h_db_sptr += sprintf(h_db_sptr, "//----------------------------------------------------------------------------------------------------------------------------------\n\n");
  h_db_sptr += sprintf(h_db_sptr, "#include \"configbitdata.h\"\n\n");
  h_db_sptr += sprintf(h_db_sptr, "//----------------------------------------------------------------------------------------------------------------------------------\n\n");

  //Separate the sub data from the main data
  h_db_mptr += sprintf(h_db_mptr, "//----------------------------------------------------------------------------------------------------------------------------------\n\n");
  
  //Convert the tile data
  convertgridfile("tilegrid");
  
  //Add a spacer between the sections
  c_db_ptr += sprintf(c_db_ptr, "\n");
  h_db_mptr += sprintf(h_db_mptr, "\n");
  
  //Convert all the bit files
  convertbitfile("clkdiv_bk1", "AA");
  convertbitfile("clkdiv_bk2", "AB");
  convertbitfile("clkdiv_bk3", "AC");
  convertbitfile("clkdiv_bk4", "AD");
  convertbitfile("clkdiv_bk5", "AE");
  convertbitfile("clkdiv_bk6", "AF");
  convertbitfile("clkdiv_bk7", "AG");
  convertbitfile("clkdiv_bk8", "AH");
  
  //Add a spacer between the sections
  h_db_mptr += sprintf(h_db_mptr, "\n");
  
  convertbitfile("emb32k_b0", "AI");
  convertbitfile("emb32k_b1", "AJ");
  
  //Add a spacer between the sections
  h_db_mptr += sprintf(h_db_mptr, "\n");
  
  convertbitfile("emb_slice", "AK");
  
  //Add a spacer between the sections
  h_db_mptr += sprintf(h_db_mptr, "\n");
  
  convertbitfile("gclk_csb", "AL");
  
  //Add a spacer between the sections
  h_db_mptr += sprintf(h_db_mptr, "\n");
  
  convertbitfile("gclk_ctmux_l", "AM");
  convertbitfile("gclk_ctmux_u", "AN");
  
  //Add a spacer between the sections
  h_db_mptr += sprintf(h_db_mptr, "\n");
  
  convertbitfile("gclk_premux_b", "AO");
  convertbitfile("gclk_premux_l", "AP");
  convertbitfile("gclk_premux_r", "AQ");
  convertbitfile("gclk_premux_t", "AR");
  
  //Add a spacer between the sections
  h_db_mptr += sprintf(h_db_mptr, "\n");
  
  convertbitfile("gclk_spine", "AS");
  
  //Add a spacer between the sections
  h_db_mptr += sprintf(h_db_mptr, "\n");
  
  convertbitfile("ioclk_bk1", "AT");
  convertbitfile("ioclk_bk2", "AU");
  convertbitfile("ioclk_bk3", "AV");
  convertbitfile("ioclk_bk4", "AW");
  convertbitfile("ioclk_bk5", "AX");
  convertbitfile("ioclk_bk6", "AY");
  convertbitfile("ioclk_bk7", "AZ");
  convertbitfile("ioclk_bk8", "BA");
  
  //Add a spacer between the sections
  h_db_mptr += sprintf(h_db_mptr, "\n");
  
  convertbitfile("iol_pair_l", "BB");
  convertbitfile("iol_pair_r", "BC");
  
  //Add a spacer between the sections
  h_db_mptr += sprintf(h_db_mptr, "\n");
  
  convertbitfile("iol_quad_b", "BD");
  convertbitfile("iol_quad_l", "BE");
  convertbitfile("iol_quad_r", "BF");
  convertbitfile("iol_quad_t", "BG");
  
  //Add a spacer between the sections
  h_db_mptr += sprintf(h_db_mptr, "\n");
  
  convertbitfile("ios_bankref_bl", "BH");
  convertbitfile("ios_bankref_br", "BI");
  convertbitfile("ios_bankref_l", "BJ");
  convertbitfile("ios_bankref_r", "BK");
  convertbitfile("ios_bankref_tl", "BL");
  convertbitfile("ios_bankref_tr", "BM");
  
  //Add a spacer between the sections
  h_db_mptr += sprintf(h_db_mptr, "\n");
  
  convertbitfile("mult", "BN");
  convertbitfile("osc", "BO");
  convertbitfile("pib", "BP");
  convertbitfile("plb", "BQ");
  convertbitfile("pll0", "BR");
  convertbitfile("pll2", "BS");
  
  //Finish the database.c file
  c_db_ptr += sprintf(c_db_ptr, "\n//----------------------------------------------------------------------------------------------------------------------------------\n\n");
  
  //Open the database.c output file
  fp = fopen("/home/peter/Data/NetbeansProjects/Code_Testing/Anlogic_bitstream_analyzer/database/database.c", "w");

  if(fp)
  {
    fprintf(fp, "%s", c_db_data);

    //Close the database.c file
    fclose(fp);
  }
  
  
  //Finish the database.h file
  h_db_mptr += sprintf(h_db_mptr, "\n//----------------------------------------------------------------------------------------------------------------------------------\n\n");
  h_db_mptr += sprintf(h_db_mptr, "#endif //DATABASE_H\n\n");
  h_db_mptr += sprintf(h_db_mptr, "//----------------------------------------------------------------------------------------------------------------------------------\n\n");
  
  //Open the database.h output file
  fp = fopen("/home/peter/Data/NetbeansProjects/Code_Testing/Anlogic_bitstream_analyzer/database/database.h", "w");

  if(fp)
  {
    fprintf(fp, "%s", h_db_sub_data);
    fprintf(fp, "%s", h_db_main_data);

    //Close the database.h file
    fclose(fp);
  }
  
}

//----------------------------------------------------------------------------------------------------------------------------------
